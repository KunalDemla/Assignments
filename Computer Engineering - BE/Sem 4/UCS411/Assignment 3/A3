{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h3>Anamika Srivastava</h3>\n",
    "<h4>COE5</h4>\n",
    "<h4>102003103</h4>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5.414213562373095 6.0 5.259921049894873\n"
     ]
    }
   ],
   "source": [
    "#question 1\n",
    "\n",
    "import sys\n",
    "import copy\n",
    "import math\n",
    "import numpy as np\n",
    "\n",
    "def find_pos(s,elem):\n",
    "    for i03 in range(len(s)):\n",
    "        for j03 in range(len(s[0])):\n",
    "            if s[i03][j03] == elem:\n",
    "                return [i03,j03]\n",
    "    return -1\n",
    "\n",
    "\n",
    "\n",
    "def eucledian(s,g):   # calculates the distance between two real-valued vectors\n",
    "    res_mat = np.zeros(len(s)*len(s[0]),dtype = float)\n",
    "    res_mat = res_mat.reshape(len(s),len(s))\n",
    "    \n",
    "    for x1_03 in range(len(s)):\n",
    "        for y1_03 in range(len(s[0])):\n",
    "            elem = s[x1_03][y1_03]\n",
    "            pos = find_pos(g,elem)\n",
    "            \n",
    "            x2_03 = pos[0]\n",
    "            y2_03 = pos[1]\n",
    "            \n",
    "            res_mat[x1_03][y1_03] = math.sqrt((x2_03-x1_03)**2 + (y2_03-y1_03)**2)\n",
    "            \n",
    "    summ_03 = 0\n",
    "    \n",
    "    for i in range(len(res_mat)):\n",
    "        summ_03 += sum(res_mat[i])\n",
    "    return summ_03\n",
    "\n",
    "\n",
    "\n",
    "def manhattan(s,g):   #calculated as the sum of the absolute differences between the two vectors\n",
    "    res_mat = np.zeros(len(s)*len(s[0]),dtype = float)\n",
    "    res_mat = res_mat.reshape(len(s),len(s))\n",
    "    \n",
    "    for x1_03 in range(len(s)):\n",
    "        for y1_03 in range(len(s[0])):\n",
    "            elem = s[x1_03][y1_03]\n",
    "            pos = find_pos(g,elem)\n",
    "            \n",
    "            x2_03 = pos[0]\n",
    "            y2_03 = pos[1]\n",
    "            \n",
    "            res_mat[x1_03][y1_03] = abs(x2_03-x1_03) + abs(y2_03-y1_03)\n",
    "            \n",
    "    summ_03 = 0\n",
    "    \n",
    "    for i in range(len(res_mat)):\n",
    "        summ_03 += sum(res_mat[i])\n",
    "    return summ_03\n",
    "\n",
    "\n",
    "def minkowiski(s,g,p): # used for nearness variable distance to find the similarity of \n",
    "                          #distances between vectors given two or more vectors\n",
    "    res_mat = np.zeros(len(s)*len(s[0]),dtype = float)\n",
    "    res_mat = res_mat.reshape(len(s),len(s))\n",
    "    \n",
    "    for x1 in range(len(s)):\n",
    "        for y1 in range(len(s[0])):\n",
    "            elem = s[x1][y1]\n",
    "            pos = find_pos(g,elem)\n",
    "            \n",
    "            x2 = pos[0]\n",
    "            y2 = pos[1]\n",
    "            \n",
    "            res_mat[x1][y1] = ((abs(x2-x1)**p) + (abs(y2-y1)**p))**(1./p)\n",
    "            \n",
    "    summ_03 = 0\n",
    "    \n",
    "    for i in range(len(res_mat)):\n",
    "        summ_03 += sum(res_mat[i])\n",
    "    return summ_03\n",
    "\n",
    "\n",
    "\n",
    "    \n",
    "def main():\n",
    "    p_val = 3\n",
    "    s0 = [[2,0,3],[1,8,4],[7,6,5]]\n",
    "    g = [[1,2,3],[8,4,0],[7,6,5]]\n",
    "    euc = eucledian(s0,g)\n",
    "    man = manhattan(s0,g)\n",
    "    mink = minkowiski(s0,g,p_val)\n",
    "\n",
    "    print (euc,man,mink)\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n",
      "5\n",
      "3\n",
      "2\n",
      "3\n",
      "found!! The intermediate states are:\n",
      "[[[2, 0, 3], [1, 8, 4], [7, 6, 5]], [[0, 2, 3], [1, 8, 4], [7, 6, 5]], [[1, 2, 3], [0, 8, 4], [7, 6, 5]], [[1, 2, 3], [8, 0, 4], [7, 6, 5]]]\n"
     ]
    }
   ],
   "source": [
    "#question 2\n",
    "\n",
    "import sys\n",
    "import copy\n",
    "\n",
    "q = []\n",
    "visited = []\n",
    "\n",
    "def compare(s,g):\n",
    "    if s==g:\n",
    "        return(1)\n",
    "    else:\n",
    "        return(0)\n",
    "\n",
    "def find_pos(s):\n",
    "    \n",
    "    for i_03 in range(3):\n",
    "        for j_03 in range(3):\n",
    "            if s[i_03][j_03] == 0:\n",
    "                return([i_03,j_03])\n",
    "\n",
    "\n",
    "def up(s,pos):\n",
    "    \n",
    "    i_03 = pos[0]\n",
    "    j_03 = pos[1]\n",
    "    \n",
    "    if i_03 > 0:\n",
    "        temp = copy.deepcopy(s)\n",
    "        temp[i_03][j_03] = temp[i_03-1][j_03]\n",
    "        temp[i_03-1][j_03] = 0\n",
    "        return (temp)\n",
    "    else:\n",
    "        return (s)\n",
    "\n",
    "    \n",
    "def down(s,pos):\n",
    "    \n",
    "    i_03 = pos[0]\n",
    "    j_03 = pos[1]\n",
    "    \n",
    "    if i_03 < 2:\n",
    "        temp = copy.deepcopy(s)\n",
    "        temp[i_03][j_03] = temp[i_03+1][j_03]\n",
    "        temp[i_03+1][j_03] = 0\n",
    "        return (temp)\n",
    "    else:\n",
    "        return (s)\n",
    "\n",
    "\n",
    "def right(s,pos):\n",
    "    \n",
    "    i_03 = pos[0]\n",
    "    j_03 = pos[1]\n",
    "    \n",
    "    if j_03 < 2:\n",
    "        temp = copy.deepcopy(s)\n",
    "        temp[i_03][j_03] = temp[i_03][j_03+1]\n",
    "        temp[i_03][j_03+1] = 0\n",
    "        return (temp)\n",
    "    else:\n",
    "        return (s)\n",
    "\n",
    "\n",
    "def left(s,pos):\n",
    "    \n",
    "    i = pos[0]\n",
    "    j = pos[1]\n",
    "    \n",
    "    if j > 0:\n",
    "        temp = copy.deepcopy(s)\n",
    "        temp[i][j] = temp[i][j-1]\n",
    "        temp[i][j-1] = 0\n",
    "        return (temp)\n",
    "    else:\n",
    "        return (s)\n",
    "\n",
    "def enqueue(s,val):\n",
    "    global q\n",
    "    q = q + [(val,s)]\n",
    "\n",
    "def heuristic(s,g):\n",
    "    d = 0\n",
    "    for i_03 in range(3):\n",
    "        for j_03 in range(3):\n",
    "            if s[i_03][j_03] != g[i_03][j_03]:\n",
    "                d += 1\n",
    "    print (d)\n",
    "    return d\n",
    "\n",
    "                \n",
    "def dequeue(g):\n",
    "    \n",
    "    global q\n",
    "    global visited\n",
    "    \n",
    "    q.sort()\n",
    "    visited = visited + [q[0][1]]\n",
    "    \n",
    "    elem = q[0][1]\n",
    "    del q[0]\n",
    "    return (elem)\n",
    "    \n",
    "def search(s,g):\n",
    "    \n",
    "    curr_state = copy.deepcopy(s)\n",
    "    if s == g:\n",
    "        return\n",
    "\n",
    "    global visited\n",
    "    while(1):\n",
    "        \n",
    "        pos = find_pos(curr_state)\n",
    "        new = up(curr_state,pos)\n",
    "\n",
    "        if new != curr_state:\n",
    "            if new == g:\n",
    "                print (\"found!! The intermediate states are:\")\n",
    "                print (visited + [g])\n",
    "                return\n",
    "            else:\n",
    "                if new not in visited:\n",
    "                    enqueue(new,heuristic(new,g))\n",
    "            \n",
    "\n",
    "        new = down(curr_state,pos)\n",
    "\n",
    "        if new != curr_state:\n",
    "            if new == g:\n",
    "                print (\"found!! The intermediate states are:\")\n",
    "                print (visited + [g])\n",
    "                return\n",
    "            else:\n",
    "                if new not in visited:\n",
    "                    enqueue(new,heuristic(new,g))\n",
    "\n",
    "        new = right(curr_state,pos)\n",
    "\n",
    "        if new != curr_state:\n",
    "            if new == g:\n",
    "                print (\"found!! The intermediate states are:\")\n",
    "                print (visited + [g])\n",
    "                return\n",
    "            else:\n",
    "                if new not in visited:\n",
    "                    enqueue(new,heuristic(new,g))\n",
    "\n",
    "        new = left(curr_state,pos)\n",
    "\n",
    "        if new != curr_state:\n",
    "            if new == g:\n",
    "                print (\"found!! The intermediate states are:\")\n",
    "                print (visited + [g])\n",
    "                return\n",
    "            else:\n",
    "                if new not in visited:\n",
    "                    enqueue(new,heuristic(new,g))\n",
    "        \n",
    "        if len(q) > 0:\n",
    "            curr_state = dequeue(g)\n",
    "        else:\n",
    "            print (\"not found\")\n",
    "            return\n",
    "        \n",
    "\n",
    "def main():\n",
    "    s = [[2,0,3],[1,8,4],[7,6,5]]\n",
    "    g = [[1,2,3],[8,0,4],[7,6,5]]\n",
    "    global q\n",
    "    global visited\n",
    "    q = q \n",
    "    visited = visited + [s]\n",
    "    \n",
    "    search(s,g)\n",
    "    \n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-------------------\n",
      "2 0 3\n",
      "1 8 4\n",
      "7 6 5\n",
      "-------------------\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'heuristic' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m~\\AppData\\Local\\Temp/ipykernel_40080/2891497088.py\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m    123\u001b[0m \u001b[0mgoal\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m3\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m8\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m4\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m7\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m6\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;36m5\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    124\u001b[0m \u001b[0mproblem\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mMyEightPuzzle\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mstart\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mgoal\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 125\u001b[1;33m \u001b[0mHillClimbing\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mproblem\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m~\\AppData\\Local\\Temp/ipykernel_40080/2891497088.py\u001b[0m in \u001b[0;36mHillClimbing\u001b[1;34m(startState)\u001b[0m\n\u001b[0;32m    100\u001b[0m         \u001b[0mthisState\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0misopen\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    101\u001b[0m         \u001b[0mthisState\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdisplayState\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 102\u001b[1;33m         \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Value of heuristic :'\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mheuristic\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mthisState\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    103\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mthisState\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mclosed\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    104\u001b[0m             \u001b[0mclosed\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mthisState\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'heuristic' is not defined"
     ]
    }
   ],
   "source": [
    "#question 3\n",
    "\n",
    "import copy\n",
    "class MyEightPuzzle:\n",
    "    def __init__(self,startState,goalState):\n",
    "        self.currentState=startState\n",
    "        self.goalState=goalState\n",
    "        self.emptyIndex=self.emptyTileIndex()\n",
    "        self.prevState=None\n",
    "    def up(self):\n",
    "        if self.emptyIndex==6 or self.emptyIndex==7 or self.emptyIndex==8:\n",
    "            print(\"cannot move\")\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex+3]\n",
    "            self.currentState[self.emptyIndex+3]=0\n",
    "            self.emptyIndex=self.emptyIndex+3\n",
    "            print('Action Up')\n",
    "            return True\n",
    "    def down(self):\n",
    "        if self.emptyIndex==0 or self.emptyIndex==1 or self.emptyIndex==2:\n",
    "            print(\"cannot move\")\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex-3]\n",
    "            self.currentState[self.emptyIndex-3]=0\n",
    "            self.emptyIndex=self.emptyIndex-3\n",
    "            print('Action down')\n",
    "            return True\n",
    "    def left(self):\n",
    "        if self.emptyIndex==2 or self.emptyIndex==5 or self.emptyIndex==8:\n",
    "            print('cannot move')\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex+1]\n",
    "            self.currentState[self.emptyIndex+1]=0\n",
    "            self.emptyIndex=self.emptyIndex+1\n",
    "            print('Action left')\n",
    "            return True\n",
    "    def right(self):\n",
    "        if self.emptyIndex==0 or self.emptyIndex==3 or self.emptyIndex==6:\n",
    "            print('cannot move')\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex-1]\n",
    "            self.currentState[self.emptyIndex-1]=0\n",
    "            self.emptyIndex=self.emptyIndex-1\n",
    "            print('Action right')\n",
    "            return True\n",
    "    def emptyTileIndex(self):\n",
    "        for i_03 in range(0,9):\n",
    "            if(self.currentState[i_03]==0):\n",
    "                return i_03\n",
    "    def isGoalReached(self):\n",
    "        if(self.currentState==self.goalState):\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "    def displayState(self):\n",
    "        print('-------------------')\n",
    "        for i in range(0,8,3):\n",
    "            print(self.currentState[i],self.currentState[i+1],self.currentState[i+2])\n",
    "        print('-------------------')\n",
    "    def __eq__(self,other):\n",
    "        return self.currentState==other.currentState\n",
    "    \n",
    "    def possible_nextstates(self):\n",
    "        stateList=[]\n",
    "        left_state=copy.deepcopy(self)\n",
    "        if left_state.left():\n",
    "            stateList.append(left_state)\n",
    "        right_state=copy.deepcopy(self)\n",
    "        if right_state.right():\n",
    "            stateList.append(right_state)\n",
    "        up_state=copy.deepcopy(self)\n",
    "        if up_state.up():\n",
    "            stateList.append(up_state)\n",
    "        down_state=copy.deepcopy(self)\n",
    "        if down_state.down():\n",
    "            stateList.append(down_state)\n",
    "        return stateList\n",
    "    def heuristic(self):\n",
    "        cnt=0\n",
    "        for i_anamika in range(0,9):\n",
    "            if self.goalState[i_anamika]!=0 and self.goalState[i_anamika]!=self.currentState[i_anamika]:\n",
    "                cnt=cnt+1\n",
    "        return cnt\n",
    "\n",
    "\n",
    "def HillClimbing(startState):\n",
    "    isopen=[]\n",
    "    closed=[]\n",
    "    nextStates=[]\n",
    "    isopen.append(startState)\n",
    "    while isopen:\n",
    "        thisState=isopen.pop(0)\n",
    "        thisState.displayState()\n",
    "        print('Value of heuristic :',heuristic(thisState))\n",
    "        if thisState not in closed:\n",
    "            closed.append(thisState)\n",
    "            if thisState.isGoalReached():\n",
    "                print('Goal state is found ..stopping search')\n",
    "                constructPath(thisState)\n",
    "                break\n",
    "            nextStates=thisState.possible_nextstates()\n",
    "            for eachstate in nextStates:\n",
    "                if eachstate not in closed and eachstate not in isopen:\n",
    "                    if eachstate.heuristic() < thisState.heuristic():\n",
    "                        isopen.append(eachstate)\n",
    "                        closed.append(thisState)\n",
    "                    \n",
    "def constructPath(gstate):\n",
    "    print('The solution path from ----goal to start----')\n",
    "    while gstate is not None:\n",
    "        gstate.displayState()\n",
    "        gstate=gstate.prevState\n",
    "\n",
    "start=[2,0,3,1,8,4,7,6,5]\n",
    "goal=[1,2,3,8,0,4,7,6,5]\n",
    "problem=MyEightPuzzle(start,goal)\n",
    "HillClimbing(problem)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-------------------\n",
      "2 0 3\n",
      "1 8 4\n",
      "7 6 5\n",
      "-------------------\n",
      "Value of heuristic : 1\n",
      "Action left\n",
      "Action right\n",
      "Action Up\n",
      "cannot move\n",
      "-------------------\n",
      "2 3 0\n",
      "1 8 4\n",
      "7 6 5\n",
      "-------------------\n",
      "Value of heuristic : 1\n",
      "cannot move\n",
      "Action right\n",
      "Action Up\n",
      "cannot move\n",
      "-------------------\n",
      "0 2 3\n",
      "1 8 4\n",
      "7 6 5\n",
      "-------------------\n",
      "Value of heuristic : 1\n",
      "Action left\n",
      "cannot move\n",
      "Action Up\n",
      "cannot move\n",
      "-------------------\n",
      "1 2 3\n",
      "0 8 4\n",
      "7 6 5\n",
      "-------------------\n",
      "Value of heuristic : 0\n",
      "Action left\n",
      "cannot move\n",
      "Action Up\n",
      "Action down\n",
      "-------------------\n",
      "1 2 3\n",
      "8 0 4\n",
      "7 6 5\n",
      "-------------------\n",
      "Value of heuristic : 0\n",
      "Goal state is found ..stopping search\n",
      "The solution path from ----goal to start----\n",
      "-------------------\n",
      "1 2 3\n",
      "8 0 4\n",
      "7 6 5\n",
      "-------------------\n",
      "-------------------\n",
      "1 2 3\n",
      "0 8 4\n",
      "7 6 5\n",
      "-------------------\n",
      "-------------------\n",
      "0 2 3\n",
      "1 8 4\n",
      "7 6 5\n",
      "-------------------\n",
      "-------------------\n",
      "2 0 3\n",
      "1 8 4\n",
      "7 6 5\n",
      "-------------------\n"
     ]
    }
   ],
   "source": [
    "#question 4\n",
    "\n",
    "import copy\n",
    "class MyEightPuzzle:\n",
    "    def __init__(self,startState,goalState):\n",
    "        self.currentState=startState\n",
    "        self.goalState=goalState\n",
    "        self.emptyIndex=self.emptyTileIndex()\n",
    "        self.prevState=None\n",
    "    def up(self):\n",
    "        if self.emptyIndex==6 or self.emptyIndex==7 or self.emptyIndex==8:\n",
    "            print(\"cannot move\")\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex+3]\n",
    "            self.currentState[self.emptyIndex+3]=0\n",
    "            self.emptyIndex=self.emptyIndex+3\n",
    "            print('Action Up')\n",
    "            return True\n",
    "    def down(self):\n",
    "        if self.emptyIndex==0 or self.emptyIndex==1 or self.emptyIndex==2:\n",
    "            print(\"cannot move\")\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex-3]\n",
    "            self.currentState[self.emptyIndex-3]=0\n",
    "            self.emptyIndex=self.emptyIndex-3\n",
    "            print('Action down')\n",
    "            return True\n",
    "    def left(self):\n",
    "        if self.emptyIndex==2 or self.emptyIndex==5 or self.emptyIndex==8:\n",
    "            print('cannot move')\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex+1]\n",
    "            self.currentState[self.emptyIndex+1]=0\n",
    "            self.emptyIndex=self.emptyIndex+1\n",
    "            print('Action left')\n",
    "            return True\n",
    "    def right(self):\n",
    "        if self.emptyIndex==0 or self.emptyIndex==3 or self.emptyIndex==6:\n",
    "            print('cannot move')\n",
    "            return False\n",
    "        else:\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            self.currentState[self.emptyIndex]=self.currentState[self.emptyIndex-1]\n",
    "            self.currentState[self.emptyIndex-1]=0\n",
    "            self.emptyIndex=self.emptyIndex-1\n",
    "            print('Action right')\n",
    "            return True\n",
    "    def emptyTileIndex(self):\n",
    "        for i_03 in range(0,9):\n",
    "            if(self.currentState[i_03]==0):\n",
    "                return i_03\n",
    "    def isGoalReached(self):\n",
    "        if(self.currentState==self.goalState):\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "    def displayState(self):\n",
    "        print('-------------------')\n",
    "        for i_anamika in range(0,8,3):\n",
    "            print(self.currentState[i_anamika],self.currentState[i_anamika+1],self.currentState[i_anamika+2])\n",
    "        print('-------------------')\n",
    "    def __eq__(self,other):\n",
    "        return self.currentState==other.currentState\n",
    "    \n",
    "    def possible_nextstates(self):\n",
    "        stateList=[]\n",
    "        left_state=copy.deepcopy(self)\n",
    "        if left_state.left():\n",
    "            stateList.append(left_state)\n",
    "        right_state=copy.deepcopy(self)\n",
    "        if right_state.right():\n",
    "            stateList.append(right_state)\n",
    "        up_state=copy.deepcopy(self)\n",
    "        if up_state.up():\n",
    "            stateList.append(up_state)\n",
    "        down_state=copy.deepcopy(self)\n",
    "        if down_state.down():\n",
    "            stateList.append(down_state)\n",
    "        return stateList\n",
    "    \n",
    "def heuristic_manhattan(self):\n",
    "    sum=0\n",
    "    for i in range(0, 9):\n",
    "        goalNode=self.goalState[i]\n",
    "        if goalNode==0:\n",
    "            continue\n",
    "        goalIndex=i\n",
    "        for j in range(0, 9):\n",
    "            currentNode=self.currentState[j]\n",
    "            if currentNode==goalNode:\n",
    "                currentIndex=j\n",
    "                break\n",
    "        diff=abs(goalIndex-currentIndex)\n",
    "        if diff<3:\n",
    "            moves=diff\n",
    "        elif diff>=3 and diff<6:\n",
    "            moves=diff%3 + 1\n",
    "        elif diff>=6 and diff<8:\n",
    "            moves=difference%3 +2\n",
    "        sum+=moves\n",
    "        return sum\n",
    "\n",
    "\n",
    "def BestFirstSearch(startState):\n",
    "    isopen=[]\n",
    "    closed=[]\n",
    "    nextStates=[]\n",
    "    isopen.append(startState)\n",
    "    while isopen:\n",
    "        thisState=isopen.pop(0)\n",
    "        thisState.displayState()\n",
    "        print('Value of heuristic :',heuristic_manhattan(thisState))\n",
    "        if thisState not in closed:\n",
    "            closed.append(thisState)\n",
    "            if thisState.isGoalReached():\n",
    "                print('Goal state is found ..stopping search')\n",
    "                constructPath(thisState)\n",
    "                break\n",
    "            nextStates=thisState.possible_nextstates()\n",
    "            for eachstate in nextStates:\n",
    "                if eachstate not in closed and eachstate not in isopen:\n",
    "                    isopen.append(eachstate)\n",
    "                    isopen.sort(key=heuristic_manhattan)\n",
    "                    \n",
    "def constructPath(gstate):\n",
    "    print('The solution path from ----goal to start----')\n",
    "    while gstate is not None:\n",
    "        gstate.displayState()\n",
    "        gstate=gstate.prevState\n",
    "start=[2,0,3,1,8,4,7,6,5]\n",
    "goal=[1,2,3,8,0,4,7,6,5]\n",
    "problem=MyEightPuzzle(start,goal)\n",
    "BestFirstSearch(problem)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-------------\n",
      "current city: 0 Cost: 0\n",
      "Visited Cities: [0]\n",
      "-------------\n",
      "Already Visited 0\n",
      "moving from city 0 to 1\n",
      "moving from city 0 to 2\n",
      "moving from city 0 to 3\n",
      "-------------\n",
      "current city: 1 Cost: 1\n",
      "Visited Cities: [0, 1]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "moving from city 1 to 2\n",
      "moving from city 1 to 3\n",
      "-------------\n",
      "current city: 2 Cost: 1\n",
      "Visited Cities: [0, 1, 2]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "moving from city 2 to 3\n",
      "-------------\n",
      "current city: 3 Cost: 1\n",
      "Visited Cities: [0, 1, 3]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "moving from city 3 to 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 3 Cost: 1\n",
      "Visited Cities: [0, 1, 2, 3]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 2 Cost: 1\n",
      "Visited Cities: [0, 1, 3, 2]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 2 Cost: 5\n",
      "Visited Cities: [0, 2]\n",
      "-------------\n",
      "Already Visited 0\n",
      "moving from city 2 to 1\n",
      "Already Visited 2\n",
      "moving from city 2 to 3\n",
      "-------------\n",
      "current city: 1 Cost: 5\n",
      "Visited Cities: [0, 2, 1]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "moving from city 1 to 3\n",
      "-------------\n",
      "current city: 3 Cost: 5\n",
      "Visited Cities: [0, 2, 3]\n",
      "-------------\n",
      "Already Visited 0\n",
      "moving from city 3 to 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 3 Cost: 5\n",
      "Visited Cities: [0, 2, 1, 3]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 1 Cost: 5\n",
      "Visited Cities: [0, 2, 3, 1]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 3 Cost: 15\n",
      "Visited Cities: [0, 3]\n",
      "-------------\n",
      "Already Visited 0\n",
      "moving from city 3 to 1\n",
      "moving from city 3 to 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 1 Cost: 15\n",
      "Visited Cities: [0, 3, 1]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "moving from city 1 to 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 2 Cost: 15\n",
      "Visited Cities: [0, 3, 2]\n",
      "-------------\n",
      "Already Visited 0\n",
      "moving from city 2 to 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 2 Cost: 15\n",
      "Visited Cities: [0, 3, 1, 2]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n",
      "-------------\n",
      "current city: 1 Cost: 15\n",
      "Visited Cities: [0, 3, 2, 1]\n",
      "-------------\n",
      "Already Visited 0\n",
      "Already Visited 1\n",
      "Already Visited 2\n",
      "Already Visited 3\n"
     ]
    }
   ],
   "source": [
    "#question 5\n",
    "\n",
    "import copy\n",
    "class ShortestPath:\n",
    "    def __init__(self, thisMap, startCity, goalCity):\n",
    "        ShortestPath.thisMap=thisMap\n",
    "        self.currentCity=startCity\n",
    "        self.goalCity=goalCity\n",
    "        self.visitedList=[]\n",
    "        self.cost=0\n",
    "        self.visitedList=[]\n",
    "        self.visitedList.append(self.currentCity)\n",
    "        self.prevState=None\n",
    "        \n",
    "    def displayState(self):\n",
    "        print('-------------')\n",
    "        print('current city:',self.currentCity,\"Cost:\",self.cost)\n",
    "        print('Visited Cities:',self.visitedList)\n",
    "        print('-------------')\n",
    "    \n",
    "    def __eq__(self, other):\n",
    "        return self.visitedList==other.visitedList\n",
    "    \n",
    "    def __lt__(self, other):\n",
    "        return self.cost<other.cost\n",
    "\n",
    "    def __gt__(self, other):\n",
    "        return self.cost>other.cost\n",
    "    \n",
    "    def isGoalReached(self):\n",
    "        if self.goalCity in self.visitedList:\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "        \n",
    "    def move(self,city):\n",
    "        if(city!=self.currentCity and city not in self.visitedList):\n",
    "            self.prevState=copy.deepcopy(self)\n",
    "            print(\"moving from city\",self.currentCity,\"to\",city)\n",
    "            self.cost=self.cost+ShortestPath.thisMap[self.currentCity][city]\n",
    "            self.currentCity=city\n",
    "            self.visitedList.append(city)\n",
    "            return True\n",
    "        else:\n",
    "            print('Already Visited',city)\n",
    "            return False\n",
    "        \n",
    "    def isGoalReached(self):\n",
    "        if len(ShortestPath.thisMap[0])==len(self.visitedList):\n",
    "            return True\n",
    "        else:\n",
    "            return False\n",
    "        \n",
    "    def possibleNextStates(self):\n",
    "        stateList=[]\n",
    "        for i_anamika in range(0,4):\n",
    "            newState=copy.deepcopy(self)\n",
    "            if newState.move(i_anamika):\n",
    "                stateList.append(newState)\n",
    "        return stateList\n",
    "\n",
    "isopen=[]\n",
    "closed=[]\n",
    "def UCS(state):\n",
    "    isopen.append(state)\n",
    "    while isopen:\n",
    "        thisState=isopen.pop(0)\n",
    "        thisState.displayState()\n",
    "        if thisState not in closed:\n",
    "            closed.append(thisState)\n",
    "            if thisState.isGoalReached():\n",
    "                print(\"Goal state found.. stopping search\")\n",
    "                constructPath(thisState)\n",
    "                break\n",
    "            else:\n",
    "                nextStates=thisState.possibleNextStates()\n",
    "                for eachState in nextStates:\n",
    "                    if eachState not in isopen and eachState not in closed:\n",
    "                        isopen.append(eachState)\n",
    "                        isopen.sort()\n",
    "                    elif eachState in isopen:\n",
    "                        index=isopen.index(eachState)\n",
    "                        if isopen[index].cost>eachState.cost:\n",
    "                            isopen.pop(index)\n",
    "                            isopen.append(eachState)\n",
    "                            isopen.sort()\n",
    "                    elif eachState in closed:\n",
    "                        index=closed.index(eachState)\n",
    "                        if closed[index].cost>eachState.cost:\n",
    "                            closed.pop(index)\n",
    "                            closed.append(eachState)\n",
    "                            propogateImprovement(eachState)\n",
    "\n",
    "def propogateImprovement(state):\n",
    "    nextStates=state.possibleNextStates()\n",
    "    for eachState in nextStates:\n",
    "        if eachState in isopen:\n",
    "            index=isopen.index[eachState]\n",
    "            if isopen[index].cost>eachState.cost:\n",
    "                isopen.pop(index)\n",
    "                isopen.append(eachState)\n",
    "                isopen.sort()\n",
    "            if eachState in closed:\n",
    "                index=closed.index(eachState)\n",
    "                if closed[index].cost>eachState.cost:\n",
    "                    closed.pop(index)\n",
    "                    closed.append(eachState)\n",
    "                    propogateImprovement(eachState)\n",
    "\n",
    "thisMap=[[0, 1, 5, 15, 0], [1, 0, 0, 0, 10], [5, 0, 0, 0, 5], [15, 0, 0, 0, 5], [0, 10, 5, 5, 0]]\n",
    "startState=0\n",
    "goalState=4\n",
    "problem=ShortestPath(thisMap, startState, goalState)\n",
    "UCS(problem)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
